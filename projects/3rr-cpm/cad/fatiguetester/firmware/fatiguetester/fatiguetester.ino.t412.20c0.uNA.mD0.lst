
/tmp/arduino_build_583183/fatiguetester.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../../crt1/gcrt1.S:63
   0:	19 c0       	rjmp	.+50     	; 0x34 <__ctors_end>
../../../../../crt1/gcrt1.S:67
   2:	28 c0       	rjmp	.+80     	; 0x54 <__bad_interrupt>
../../../../../crt1/gcrt1.S:68
   4:	27 c0       	rjmp	.+78     	; 0x54 <__bad_interrupt>
../../../../../crt1/gcrt1.S:69
   6:	26 c0       	rjmp	.+76     	; 0x54 <__bad_interrupt>
../../../../../crt1/gcrt1.S:70
   8:	25 c0       	rjmp	.+74     	; 0x54 <__bad_interrupt>
../../../../../crt1/gcrt1.S:71
   a:	24 c0       	rjmp	.+72     	; 0x54 <__bad_interrupt>
../../../../../crt1/gcrt1.S:72
   c:	23 c0       	rjmp	.+70     	; 0x54 <__bad_interrupt>
../../../../../crt1/gcrt1.S:73
   e:	22 c0       	rjmp	.+68     	; 0x54 <__bad_interrupt>
../../../../../crt1/gcrt1.S:74
  10:	21 c0       	rjmp	.+66     	; 0x54 <__bad_interrupt>
../../../../../crt1/gcrt1.S:75
  12:	20 c0       	rjmp	.+64     	; 0x54 <__bad_interrupt>
../../../../../crt1/gcrt1.S:76
  14:	1f c0       	rjmp	.+62     	; 0x54 <__bad_interrupt>
../../../../../crt1/gcrt1.S:77
  16:	1e c0       	rjmp	.+60     	; 0x54 <__bad_interrupt>
../../../../../crt1/gcrt1.S:78
  18:	1d c0       	rjmp	.+58     	; 0x54 <__bad_interrupt>
../../../../../crt1/gcrt1.S:79
  1a:	1c c0       	rjmp	.+56     	; 0x54 <__bad_interrupt>
../../../../../crt1/gcrt1.S:80
  1c:	8a c0       	rjmp	.+276    	; 0x132 <__vector_14>
../../../../../crt1/gcrt1.S:81
  1e:	1a c0       	rjmp	.+52     	; 0x54 <__bad_interrupt>
../../../../../crt1/gcrt1.S:82
  20:	19 c0       	rjmp	.+50     	; 0x54 <__bad_interrupt>
../../../../../crt1/gcrt1.S:83
  22:	18 c0       	rjmp	.+48     	; 0x54 <__bad_interrupt>
../../../../../crt1/gcrt1.S:84
  24:	17 c0       	rjmp	.+46     	; 0x54 <__bad_interrupt>
../../../../../crt1/gcrt1.S:85
  26:	16 c0       	rjmp	.+44     	; 0x54 <__bad_interrupt>
../../../../../crt1/gcrt1.S:86
  28:	15 c0       	rjmp	.+42     	; 0x54 <__bad_interrupt>
../../../../../crt1/gcrt1.S:87
  2a:	14 c0       	rjmp	.+40     	; 0x54 <__bad_interrupt>
../../../../../crt1/gcrt1.S:88
  2c:	13 c0       	rjmp	.+38     	; 0x54 <__bad_interrupt>
../../../../../crt1/gcrt1.S:89
  2e:	12 c0       	rjmp	.+36     	; 0x54 <__bad_interrupt>
../../../../../crt1/gcrt1.S:90
  30:	11 c0       	rjmp	.+34     	; 0x54 <__bad_interrupt>
../../../../../crt1/gcrt1.S:91
  32:	10 c0       	rjmp	.+32     	; 0x54 <__bad_interrupt>

00000034 <__ctors_end>:
__trampolines_start():
../../../../../crt1/gcrt1.S:230
  34:	11 24       	eor	r1, r1
../../../../../crt1/gcrt1.S:231
  36:	1f be       	out	0x3f, r1	; 63
../../../../../crt1/gcrt1.S:232
  38:	cf ef       	ldi	r28, 0xFF	; 255
../../../../../crt1/gcrt1.S:234
  3a:	cd bf       	out	0x3d, r28	; 61
../../../../../crt1/gcrt1.S:236
  3c:	df e3       	ldi	r29, 0x3F	; 63
../../../../../crt1/gcrt1.S:237
  3e:	de bf       	out	0x3e, r29	; 62

00000040 <__do_clear_bss>:
__do_clear_bss():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  40:	2f e3       	ldi	r18, 0x3F	; 63
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  42:	a0 e0       	ldi	r26, 0x00	; 0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  44:	bf e3       	ldi	r27, 0x3F	; 63
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  46:	01 c0       	rjmp	.+2      	; 0x4a <.do_clear_bss_start>

00000048 <.do_clear_bss_loop>:
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  48:	1d 92       	st	X+, r1

0000004a <.do_clear_bss_start>:
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  4a:	aa 30       	cpi	r26, 0x0A	; 10
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  4c:	b2 07       	cpc	r27, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  4e:	e1 f7       	brne	.-8      	; 0x48 <.do_clear_bss_loop>
.do_clear_bss_start():
../../../../../crt1/gcrt1.S:314
  50:	c6 d0       	rcall	.+396    	; 0x1de <main>
../../../../../crt1/gcrt1.S:315
  52:	5d c1       	rjmp	.+698    	; 0x30e <_exit>

00000054 <__bad_interrupt>:
__vector_22():
../../../../../crt1/gcrt1.S:209
  54:	d5 cf       	rjmp	.-86     	; 0x0 <__vectors>

00000056 <micros>:
micros():
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:233
  #else
    uint8_t ticks;
  #endif
  uint8_t flags;
  /* Save current state and disable interrupts */
  uint8_t oldSREG = SREG;
  56:	9f b7       	in	r25, 0x3f	; 63
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:234
  cli();
  58:	f8 94       	cli
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:241

  #if defined(MILLIS_USE_TIMERA0)
    ticks = TCA0.SPLIT.HCNT;
    flags = TCA0.SPLIT.INTFLAGS;
  #elif defined(MILLIS_USE_TIMERD0)
    TCD0.CTRLE = TCD_SCAPTUREA_bm;
  5a:	88 e0       	ldi	r24, 0x08	; 8
  5c:	80 93 84 0a 	sts	0x0A84, r24	; 0x800a84 <__RODATA_PM_OFFSET__+0x7f8a84>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:242
    while (!(TCD0.STATUS & TCD_CMDRDY_bm)); //wait for sync - should be only one iteration of this loop
  60:	80 91 8e 0a 	lds	r24, 0x0A8E	; 0x800a8e <__RODATA_PM_OFFSET__+0x7f8a8e>
  64:	81 ff       	sbrs	r24, 1
  66:	fc cf       	rjmp	.-8      	; 0x60 <micros+0xa>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:243
    flags = TCD0.INTFLAGS;
  68:	80 91 8d 0a 	lds	r24, 0x0A8D	; 0x800a8d <__RODATA_PM_OFFSET__+0x7f8a8d>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:244
    ticks = TCD0.CAPTUREA;
  6c:	e0 91 a2 0a 	lds	r30, 0x0AA2	; 0x800aa2 <__RODATA_PM_OFFSET__+0x7f8aa2>
  70:	f0 91 a3 0a 	lds	r31, 0x0AA3	; 0x800aa3 <__RODATA_PM_OFFSET__+0x7f8aa3>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:255
    ISR has not fired. If we already read a high value of ticks, either we read it just before the overflow,
    so we shouldn't increment overflows, or interrupts are disabled and micros isn't expected to work so it doesn't matter
  */
  /* Get current number of overflows and timer count */
  #if !(defined(MILLIS_USE_TIMERB0) || defined(MILLIS_USE_TIMERB1))
    overflows = timer_overflow_count;
  74:	20 91 06 3f 	lds	r18, 0x3F06	; 0x803f06 <timer_overflow_count>
  78:	30 91 07 3f 	lds	r19, 0x3F07	; 0x803f07 <timer_overflow_count+0x1>
  7c:	40 91 08 3f 	lds	r20, 0x3F08	; 0x803f08 <timer_overflow_count+0x2>
  80:	50 91 09 3f 	lds	r21, 0x3F09	; 0x803f09 <timer_overflow_count+0x3>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:261
  #else
    overflows = timer_millis;
  #endif

    /* Turn interrupts back on, assuming they were on when micros was called. */
    SREG = oldSREG;
  84:	9f bf       	out	0x3f, r25	; 63
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:264

  #if defined(MILLIS_USE_TIMERD0)
    if ((flags & TCD_OVF_bm) && (ticks < 0x07)) {
  86:	80 ff       	sbrs	r24, 0
  88:	07 c0       	rjmp	.+14     	; 0x98 <__EEPROM_REGION_LENGTH__+0x18>
  8a:	e7 30       	cpi	r30, 0x07	; 7
  8c:	f1 05       	cpc	r31, r1
  8e:	20 f4       	brcc	.+8      	; 0x98 <__EEPROM_REGION_LENGTH__+0x18>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:274
    if ((flags & TCB_CAPT_bm) && !(ticks & 0xFF00)) {
  #endif
    #if ((defined(MILLIS_USE_TIMERB0) || defined(MILLIS_USE_TIMERB1)) && (F_CPU <= 1000000))
      overflows += 2;
    #else
      overflows++;
  90:	2f 5f       	subi	r18, 0xFF	; 255
  92:	3f 4f       	sbci	r19, 0xFF	; 255
  94:	4f 4f       	sbci	r20, 0xFF	; 255
  96:	5f 4f       	sbci	r21, 0xFF	; 255
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:280
    #endif
  } //end getting ticks

  #if defined(MILLIS_USE_TIMERD0)
    #if (F_CPU==20000000UL || F_CPU==10000000UL || F_CPU==5000000UL)
      uint8_t ticks_l = ticks >> 1;
  98:	bf 01       	movw	r22, r30
  9a:	76 95       	lsr	r23
  9c:	67 95       	ror	r22
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:281
      ticks = ticks + ticks_l + ((ticks_l >> 2) - (ticks_l >> 4) + (ticks_l >> 7));
  9e:	cf 01       	movw	r24, r30
  a0:	86 0f       	add	r24, r22
  a2:	91 1d       	adc	r25, r1
  a4:	e6 2f       	mov	r30, r22
  a6:	e6 95       	lsr	r30
  a8:	e6 95       	lsr	r30
  aa:	76 2f       	mov	r23, r22
  ac:	72 95       	swap	r23
  ae:	7f 70       	andi	r23, 0x0F	; 15
  b0:	e7 1b       	sub	r30, r23
  b2:	ff 0b       	sbc	r31, r31
  b4:	67 fd       	sbrc	r22, 7
  b6:	31 96       	adiw	r30, 0x01	; 1
  b8:	e8 0f       	add	r30, r24
  ba:	f9 1f       	adc	r31, r25
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:284
      // + ticks +(ticks>>1)+(ticks>>3)-(ticks>>5)+(ticks>>8))
      // speed optimization via doing math with smaller datatypes, since we know high byte is 1 or 0. also saves us some painful
      microseconds = overflows * (TIME_TRACKING_CYCLES_PER_OVF / (20))
  bc:	a0 e3       	ldi	r26, 0x30	; 48
  be:	b3 e0       	ldi	r27, 0x03	; 3
  c0:	10 d1       	rcall	.+544    	; 0x2e2 <__muluhisi3>
  c2:	6e 0f       	add	r22, r30
  c4:	7f 1f       	adc	r23, r31
  c6:	81 1d       	adc	r24, r1
  c8:	91 1d       	adc	r25, r1
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:338
      microseconds = ((overflows * millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF))
                    + (ticks * (millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF) / TIME_TRACKING_TIMER_PERIOD)));
    #endif
  #endif //end of timer-specific part of micros calculations
  return microseconds;
}
  ca:	08 95       	ret

000000cc <delay.constprop.0>:
delay.constprop.0():
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:345


#endif //end of non-MILLIS_USE_TIMERNONE code

#if !(defined(MILLIS_USE_TIMERNONE) || defined(MILLIS_USE_TIMERRTC)) //delay implementation when we do have micros()
void delay(unsigned long ms) {
  cc:	8f 92       	push	r8
  ce:	9f 92       	push	r9
  d0:	af 92       	push	r10
  d2:	bf 92       	push	r11
  d4:	cf 92       	push	r12
  d6:	df 92       	push	r13
  d8:	ef 92       	push	r14
  da:	ff 92       	push	r15
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:370

    /* Wait until return time */
    while (micros() < return_time);
  #else
    //Otherwise, we use the normal implementation of delay which is compatible with all values that fit in uint32_t.
    uint32_t start = micros();
  dc:	bc df       	rcall	.-136    	; 0x56 <micros>
  de:	4b 01       	movw	r8, r22
  e0:	5c 01       	movw	r10, r24
  e2:	84 e6       	ldi	r24, 0x64	; 100
  e4:	c8 2e       	mov	r12, r24
  e6:	d1 2c       	mov	r13, r1
  e8:	e1 2c       	mov	r14, r1
  ea:	f1 2c       	mov	r15, r1
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:373

    while (ms > 0) {
      while ( ms > 0 && (micros() - start) >= 1000) {
  ec:	b4 df       	rcall	.-152    	; 0x56 <micros>
  ee:	68 19       	sub	r22, r8
  f0:	79 09       	sbc	r23, r9
  f2:	8a 09       	sbc	r24, r10
  f4:	9b 09       	sbc	r25, r11
  f6:	68 3e       	cpi	r22, 0xE8	; 232
  f8:	73 40       	sbci	r23, 0x03	; 3
  fa:	81 05       	cpc	r24, r1
  fc:	91 05       	cpc	r25, r1
  fe:	b0 f3       	brcs	.-20     	; 0xec <delay.constprop.0+0x20>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:374
        ms--;
 100:	21 e0       	ldi	r18, 0x01	; 1
 102:	c2 1a       	sub	r12, r18
 104:	d1 08       	sbc	r13, r1
 106:	e1 08       	sbc	r14, r1
 108:	f1 08       	sbc	r15, r1
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:375
        start += 1000;
 10a:	88 ee       	ldi	r24, 0xE8	; 232
 10c:	88 0e       	add	r8, r24
 10e:	83 e0       	ldi	r24, 0x03	; 3
 110:	98 1e       	adc	r9, r24
 112:	a1 1c       	adc	r10, r1
 114:	b1 1c       	adc	r11, r1
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:373
  #else
    //Otherwise, we use the normal implementation of delay which is compatible with all values that fit in uint32_t.
    uint32_t start = micros();

    while (ms > 0) {
      while ( ms > 0 && (micros() - start) >= 1000) {
 116:	c1 14       	cp	r12, r1
 118:	d1 04       	cpc	r13, r1
 11a:	e1 04       	cpc	r14, r1
 11c:	f1 04       	cpc	r15, r1
 11e:	31 f7       	brne	.-52     	; 0xec <delay.constprop.0+0x20>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:379
        ms--;
        start += 1000;
      }
    }
  #endif
}
 120:	ff 90       	pop	r15
 122:	ef 90       	pop	r14
 124:	df 90       	pop	r13
 126:	cf 90       	pop	r12
 128:	bf 90       	pop	r11
 12a:	af 90       	pop	r10
 12c:	9f 90       	pop	r9
 12e:	8f 90       	pop	r8
 130:	08 95       	ret

00000132 <__vector_14>:
__vector_14():
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:139
#elif defined(MILLIS_USE_TIMERB1)
  ISR(TCB1_INT_vect)
#else
  #error "No millis timer selected, but not disabled - cannot determine millis vector"
#endif
{
 132:	1f 92       	push	r1
 134:	0f 92       	push	r0
 136:	0f b6       	in	r0, 0x3f	; 63
 138:	0f 92       	push	r0
 13a:	11 24       	eor	r1, r1
 13c:	2f 93       	push	r18
 13e:	3f 93       	push	r19
 140:	4f 93       	push	r20
 142:	5f 93       	push	r21
 144:	6f 93       	push	r22
 146:	8f 93       	push	r24
 148:	9f 93       	push	r25
 14a:	af 93       	push	r26
 14c:	bf 93       	push	r27
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:151
    #else
      timer_millis += 2;
    #endif
  #else
    #if !defined(MILLIS_USE_TIMERRTC) //TCA0 or TCD0
      uint32_t m = timer_millis;
 14e:	80 91 02 3f 	lds	r24, 0x3F02	; 0x803f02 <timer_millis>
 152:	90 91 03 3f 	lds	r25, 0x3F03	; 0x803f03 <timer_millis+0x1>
 156:	a0 91 04 3f 	lds	r26, 0x3F04	; 0x803f04 <timer_millis+0x2>
 15a:	b0 91 05 3f 	lds	r27, 0x3F05	; 0x803f05 <timer_millis+0x3>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:152
      uint16_t f = timer_fract;
 15e:	40 91 00 3f 	lds	r20, 0x3F00	; 0x803f00 <__DATA_REGION_ORIGIN__>
 162:	50 91 01 3f 	lds	r21, 0x3F01	; 0x803f01 <__DATA_REGION_ORIGIN__+0x1>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:154
      m += MILLIS_INC;
      f += FRACT_INC;
 166:	9a 01       	movw	r18, r20
 168:	20 5d       	subi	r18, 0xD0	; 208
 16a:	3c 4f       	sbci	r19, 0xFC	; 252
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:155
      if (f >= FRACT_MAX) {
 16c:	28 3e       	cpi	r18, 0xE8	; 232
 16e:	63 e0       	ldi	r22, 0x03	; 3
 170:	36 07       	cpc	r19, r22
 172:	28 f0       	brcs	.+10     	; 0x17e <__vector_14+0x4c>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:157

        f -= FRACT_MAX;
 174:	28 5e       	subi	r18, 0xE8	; 232
 176:	33 40       	sbci	r19, 0x03	; 3
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:158
        m += 1;
 178:	01 96       	adiw	r24, 0x01	; 1
 17a:	a1 1d       	adc	r26, r1
 17c:	b1 1d       	adc	r27, r1
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:160
      }
      timer_fract = f;
 17e:	20 93 00 3f 	sts	0x3F00, r18	; 0x803f00 <__DATA_REGION_ORIGIN__>
 182:	30 93 01 3f 	sts	0x3F01, r19	; 0x803f01 <__DATA_REGION_ORIGIN__+0x1>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:161
      timer_millis = m;
 186:	80 93 02 3f 	sts	0x3F02, r24	; 0x803f02 <timer_millis>
 18a:	90 93 03 3f 	sts	0x3F03, r25	; 0x803f03 <timer_millis+0x1>
 18e:	a0 93 04 3f 	sts	0x3F04, r26	; 0x803f04 <timer_millis+0x2>
 192:	b0 93 05 3f 	sts	0x3F05, r27	; 0x803f05 <timer_millis+0x3>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:164
    #endif
    //if RTC is used as timer, we only increment the overflow count
    timer_overflow_count++;
 196:	80 91 06 3f 	lds	r24, 0x3F06	; 0x803f06 <timer_overflow_count>
 19a:	90 91 07 3f 	lds	r25, 0x3F07	; 0x803f07 <timer_overflow_count+0x1>
 19e:	a0 91 08 3f 	lds	r26, 0x3F08	; 0x803f08 <timer_overflow_count+0x2>
 1a2:	b0 91 09 3f 	lds	r27, 0x3F09	; 0x803f09 <timer_overflow_count+0x3>
 1a6:	01 96       	adiw	r24, 0x01	; 1
 1a8:	a1 1d       	adc	r26, r1
 1aa:	b1 1d       	adc	r27, r1
 1ac:	80 93 06 3f 	sts	0x3F06, r24	; 0x803f06 <timer_overflow_count>
 1b0:	90 93 07 3f 	sts	0x3F07, r25	; 0x803f07 <timer_overflow_count+0x1>
 1b4:	a0 93 08 3f 	sts	0x3F08, r26	; 0x803f08 <timer_overflow_count+0x2>
 1b8:	b0 93 09 3f 	sts	0x3F09, r27	; 0x803f09 <timer_overflow_count+0x3>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:170
  #endif
  /* Clear flag */
  #if defined(MILLIS_USE_TIMERA0)
    TCA0.SPLIT.INTFLAGS = TCA_SPLIT_HUNF_bm;
  #elif defined(MILLIS_USE_TIMERD0)
    TCD0.INTFLAGS = TCD_OVF_bm;
 1bc:	81 e0       	ldi	r24, 0x01	; 1
 1be:	80 93 8d 0a 	sts	0x0A8D, r24	; 0x800a8d <__RODATA_PM_OFFSET__+0x7f8a8d>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:176
  #elif defined(MILLIS_USE_TIMERRTC)
    RTC.INTFLAGS = RTC_OVF_bm;
  #else //timerb
    _timer->INTFLAGS = TCB_CAPT_bm;
  #endif
}
 1c2:	bf 91       	pop	r27
 1c4:	af 91       	pop	r26
 1c6:	9f 91       	pop	r25
 1c8:	8f 91       	pop	r24
 1ca:	6f 91       	pop	r22
 1cc:	5f 91       	pop	r21
 1ce:	4f 91       	pop	r20
 1d0:	3f 91       	pop	r19
 1d2:	2f 91       	pop	r18
 1d4:	0f 90       	pop	r0
 1d6:	0f be       	out	0x3f, r0	; 63
 1d8:	0f 90       	pop	r0
 1da:	1f 90       	pop	r1
 1dc:	18 95       	reti

000001de <main>:
main():
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:673
    #error "CLOCK_SOURCE not defined. CLOCK_SOURCE must be either 0 (internal) or 2 (external clock)"
  #endif
  #if (CLOCK_SOURCE==0)
    #if (F_CPU == 20000000)
      /* No division on clock */
      _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00);
 1de:	88 ed       	ldi	r24, 0xD8	; 216
 1e0:	90 e0       	ldi	r25, 0x00	; 0
 1e2:	84 bf       	out	0x34, r24	; 52
 1e4:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__RODATA_PM_OFFSET__+0x7f8061>
init_ADC0():
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:727
     * apart. On the 2-series and Dx-series, they are MUCH closer together.
     **************************************************************************/
    #if F_CPU     > 24000000    // 24 MHz / 16 = 1.5 MHz,  25 MHz / 32 =  780 kHz
      ADC0.CTRLC  = ADC_PRESC_DIV16_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
    #elif F_CPU  >= 12000000    // 16 MHz / 16 = 1.0 MHz,  20 MHz / 16 = 1.25 MHz
      ADC0.CTRLC  = ADC_PRESC_DIV16_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
 1e8:	83 e5       	ldi	r24, 0x53	; 83
 1ea:	80 93 02 06 	sts	0x0602, r24	; 0x800602 <__RODATA_PM_OFFSET__+0x7f8602>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:735
    #elif F_CPU  >=  3000000    //  4 MHz /  4 = 1.0 MHz,   5 MHz /  4 = 1.25 MHz
      ADC0.CTRLC  = ADC_PRESC_DIV4_gc  | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
    #else                       //  1 MHz /  2 = 500 kHz - the lowest setting
      ADC0.CTRLC  = ADC_PRESC_DIV2_gc  | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
    #endif
    ADC0.SAMPCTRL = (16); // 16 ADC clocks, 16 us
 1ee:	80 e1       	ldi	r24, 0x10	; 16
 1f0:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__RODATA_PM_OFFSET__+0x7f8605>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:736
    ADC0.CTRLD    = ADC_INITDLY_DLY16_gc;
 1f4:	80 e2       	ldi	r24, 0x20	; 32
 1f6:	80 93 03 06 	sts	0x0603, r24	; 0x800603 <__RODATA_PM_OFFSET__+0x7f8603>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:737
    ADC0.CTRLA   |= ADC_ENABLE_bm;
 1fa:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <__RODATA_PM_OFFSET__+0x7f8600>
 1fe:	81 60       	ori	r24, 0x01	; 1
 200:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__RODATA_PM_OFFSET__+0x7f8600>
init_TCA0():
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:816

  /* PORTMUX setting for TCA - don't need to set because using default */
  //PORTMUX.CTRLA = PORTMUX_TCA00_DEFAULT_gc;

  /* Enable Split Mode */
  TCA0.SPLIT.CTRLD = TCA_SPLIT_SPLITM_bm;
 204:	81 e0       	ldi	r24, 0x01	; 1
 206:	80 93 03 0a 	sts	0x0A03, r24	; 0x800a03 <__RODATA_PM_OFFSET__+0x7f8a03>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:821

  //Only 1 WGM so no need to specifically set up.

  /* Period setting, 8-bit register in SPLIT mode */
  TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
 20a:	9e ef       	ldi	r25, 0xFE	; 254
 20c:	90 93 26 0a 	sts	0x0A26, r25	; 0x800a26 <__RODATA_PM_OFFSET__+0x7f8a26>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:822
  TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
 210:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <__RODATA_PM_OFFSET__+0x7f8a27>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:839

  /* Use prescale appropriate for system clock speed */
  #if (F_CPU > 25000000) //   use 256 divider when clocked over 25 MHz - probably not terribly relevant - though they might be viable at 30 or 32, and are viable at 24/25 MHz.
    TCA0.SPLIT.CTRLA   = (TCA_SPLIT_CLKSEL_DIV256_gc) | (TCA_SPLIT_ENABLE_bm);
  #elif (F_CPU > 5000000) //  use 64 divider
    TCA0.SPLIT.CTRLA   =  (TCA_SPLIT_CLKSEL_DIV64_gc) | (TCA_SPLIT_ENABLE_bm);
 214:	9b e0       	ldi	r25, 0x0B	; 11
 216:	90 93 00 0a 	sts	0x0A00, r25	; 0x800a00 <__RODATA_PM_OFFSET__+0x7f8a00>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:846
    TCA0.SPLIT.CTRLA   =  (TCA_SPLIT_CLKSEL_DIV16_gc) | (TCA_SPLIT_ENABLE_bm);
  #else //TIME_TRACKING_TIMER_DIVIDER==8
    TCA0.SPLIT.CTRLA   =   (TCA_SPLIT_CLKSEL_DIV8_gc) | (TCA_SPLIT_ENABLE_bm);
  #endif
  #ifdef __AVR_ATtinyxy2__
    PORTMUX.CTRLC = 1; //move WO0 output to PA7 so PA3 can be used with WO3
 21a:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <__RODATA_PM_OFFSET__+0x7f8202>
init_millis():
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:598
    #if defined(MILLIS_USE_TIMERA0)
      TCA0.SPLIT.INTCTRL |= TCA_SPLIT_HUNF_bm;
    #elif defined(MILLIS_USE_TIMERA1)
      TCA1.SPLIT.INTCTRL |= TCA_SPLIT_HUNF_bm;
    #elif defined(MILLIS_USE_TIMERD0)
      TCD0.CMPBCLR        = TIME_TRACKING_TIMER_PERIOD; //essentially, this is TOP
 21e:	2d ef       	ldi	r18, 0xFD	; 253
 220:	31 e0       	ldi	r19, 0x01	; 1
 222:	20 93 ae 0a 	sts	0x0AAE, r18	; 0x800aae <__RODATA_PM_OFFSET__+0x7f8aae>
 226:	30 93 af 0a 	sts	0x0AAF, r19	; 0x800aaf <__RODATA_PM_OFFSET__+0x7f8aaf>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:599
      TCD0.INTCTRL        = 0x01;//enable interrupt
 22a:	80 93 8c 0a 	sts	0x0A8C, r24	; 0x800a8c <__RODATA_PM_OFFSET__+0x7f8a8c>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:600
      TCD0.CTRLB          = 0x00; //oneramp mode
 22e:	10 92 81 0a 	sts	0x0A81, r1	; 0x800a81 <__RODATA_PM_OFFSET__+0x7f8a81>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:601
      TCD0.CTRLC          = 0x80;
 232:	80 e8       	ldi	r24, 0x80	; 128
 234:	80 93 82 0a 	sts	0x0A82, r24	; 0x800a82 <__RODATA_PM_OFFSET__+0x7f8a82>
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:602
      TCD0.CTRLA          = TIMERD0_PRESCALER | 0x01; //set clock source and enable!
 238:	81 e1       	ldi	r24, 0x11	; 17
 23a:	80 93 80 0a 	sts	0x0A80, r24	; 0x800a80 <__RODATA_PM_OFFSET__+0x7f8a80>
main():
/home/zach/.arduino15/packages/megaTinyCore/hardware/megaavr/2.3.2/cores/megatinycore/wiring.c:662
  #ifndef MILLIS_USE_TIMERNONE
    init_millis();
  #endif
  /*************************** ENABLE GLOBAL INTERRUPTS *************************/
  // Finally, after everything is initialized, we go ahead and enable interrupts.
  sei();
 23e:	78 94       	sei
setup():
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:9
#define SERVO PIN1_bm
#define SENSE PIN3_bm

void setup() {
    // init _everything_ since reprogramming != reset
    TCA0.SINGLE.CTRLA = 0;
 240:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__RODATA_PM_OFFSET__+0x7f8a00>
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:10
    TCA0.SINGLE.CTRLB = 0;
 244:	10 92 01 0a 	sts	0x0A01, r1	; 0x800a01 <__RODATA_PM_OFFSET__+0x7f8a01>
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:11
    TCA0.SINGLE.CTRLC = 0;
 248:	10 92 02 0a 	sts	0x0A02, r1	; 0x800a02 <__RODATA_PM_OFFSET__+0x7f8a02>
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:12
    TCA0.SINGLE.CTRLD = 0;
 24c:	10 92 03 0a 	sts	0x0A03, r1	; 0x800a03 <__RODATA_PM_OFFSET__+0x7f8a03>
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:15

    // set up timer TCA for servo output on pin 4 / PA1 / W01
    TCA0.SINGLE.CTRLA |= ((1<<1) | (1<<3)); // fclk/64 (312.5 kHz)
 250:	80 91 00 0a 	lds	r24, 0x0A00	; 0x800a00 <__RODATA_PM_OFFSET__+0x7f8a00>
 254:	8a 60       	ori	r24, 0x0A	; 10
 256:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__RODATA_PM_OFFSET__+0x7f8a00>
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:16
    TCA0.SINGLE.PER = 6250; //pwm period = ~50 Hz
 25a:	8a e6       	ldi	r24, 0x6A	; 106
 25c:	98 e1       	ldi	r25, 0x18	; 24
 25e:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <__RODATA_PM_OFFSET__+0x7f8a26>
 262:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <__RODATA_PM_OFFSET__+0x7f8a27>
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:17
    TCA0.SINGLE.CMP1 = 625; //starting pulse width = 1.5 ms
 266:	81 e7       	ldi	r24, 0x71	; 113
 268:	92 e0       	ldi	r25, 0x02	; 2
 26a:	80 93 2a 0a 	sts	0x0A2A, r24	; 0x800a2a <__RODATA_PM_OFFSET__+0x7f8a2a>
 26e:	90 93 2b 0a 	sts	0x0A2B, r25	; 0x800a2b <__RODATA_PM_OFFSET__+0x7f8a2b>
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:18
    TCA0.SINGLE.CTRLB |= (1<<5); //enable compare TCA W01
 272:	80 91 01 0a 	lds	r24, 0x0A01	; 0x800a01 <__RODATA_PM_OFFSET__+0x7f8a01>
 276:	80 62       	ori	r24, 0x20	; 32
 278:	80 93 01 0a 	sts	0x0A01, r24	; 0x800a01 <__RODATA_PM_OFFSET__+0x7f8a01>
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:19
    TCA0.SINGLE.CTRLB |= ((1<<0) | (1<<1)); //set TCA to single-slope PWM mode
 27c:	80 91 01 0a 	lds	r24, 0x0A01	; 0x800a01 <__RODATA_PM_OFFSET__+0x7f8a01>
 280:	83 60       	ori	r24, 0x03	; 3
 282:	80 93 01 0a 	sts	0x0A01, r24	; 0x800a01 <__RODATA_PM_OFFSET__+0x7f8a01>
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:20
    TCA0.SINGLE.CTRLA |= (1<<0); //enable timer TCA
 286:	80 91 00 0a 	lds	r24, 0x0A00	; 0x800a00 <__RODATA_PM_OFFSET__+0x7f8a00>
 28a:	81 60       	ori	r24, 0x01	; 1
 28c:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__RODATA_PM_OFFSET__+0x7f8a00>
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:23

    // GPIO setup
    PORTA.DIRSET = LED;
 290:	84 e0       	ldi	r24, 0x04	; 4
 292:	80 93 01 04 	sts	0x0401, r24	; 0x800401 <__RODATA_PM_OFFSET__+0x7f8401>
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:24
    PORTA.DIRSET = SERVO;
 296:	82 e0       	ldi	r24, 0x02	; 2
 298:	80 93 01 04 	sts	0x0401, r24	; 0x800401 <__RODATA_PM_OFFSET__+0x7f8401>
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:25
    PORTA.DIRCLR = SENSE;
 29c:	88 e0       	ldi	r24, 0x08	; 8
 29e:	80 93 02 04 	sts	0x0402, r24	; 0x800402 <__RODATA_PM_OFFSET__+0x7f8402>
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:26
    PORTA.PIN3CTRL |= (1<<3); //enable pullup on sense line
 2a2:	80 91 13 04 	lds	r24, 0x0413	; 0x800413 <__RODATA_PM_OFFSET__+0x7f8413>
 2a6:	88 60       	ori	r24, 0x08	; 8
 2a8:	80 93 13 04 	sts	0x0413, r24	; 0x800413 <__RODATA_PM_OFFSET__+0x7f8413>
loop():
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:35
    // 75 TCA0 counts = 26.3 degrees --> 43 counts is around 15 degrees (verified with ImageJ)
  if (PORTA.IN & SENSE) {
    PORTA.OUTCLR = LED;
  }
  else {
    PORTA.OUTSET = LED;
 2ac:	c4 e0       	ldi	r28, 0x04	; 4
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:36
    TCA0.SINGLE.CMP1 = 625;
 2ae:	81 e7       	ldi	r24, 0x71	; 113
 2b0:	e8 2e       	mov	r14, r24
 2b2:	82 e0       	ldi	r24, 0x02	; 2
 2b4:	f8 2e       	mov	r15, r24
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:38
    delay(100);
    TCA0.SINGLE.CMP1 = 582;
 2b6:	06 e4       	ldi	r16, 0x46	; 70
 2b8:	12 e0       	ldi	r17, 0x02	; 2
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:31
    PORTA.PIN3CTRL |= (1<<3); //enable pullup on sense line
}

void loop() {
    // 75 TCA0 counts = 26.3 degrees --> 43 counts is around 15 degrees (verified with ImageJ)
  if (PORTA.IN & SENSE) {
 2ba:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__RODATA_PM_OFFSET__+0x7f8408>
 2be:	83 ff       	sbrs	r24, 3
 2c0:	03 c0       	rjmp	.+6      	; 0x2c8 <main+0xea>
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:32
    PORTA.OUTCLR = LED;
 2c2:	c0 93 06 04 	sts	0x0406, r28	; 0x800406 <__RODATA_PM_OFFSET__+0x7f8406>
 2c6:	f9 cf       	rjmp	.-14     	; 0x2ba <main+0xdc>
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:35
  }
  else {
    PORTA.OUTSET = LED;
 2c8:	c0 93 05 04 	sts	0x0405, r28	; 0x800405 <__RODATA_PM_OFFSET__+0x7f8405>
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:36
    TCA0.SINGLE.CMP1 = 625;
 2cc:	e0 92 2a 0a 	sts	0x0A2A, r14	; 0x800a2a <__RODATA_PM_OFFSET__+0x7f8a2a>
 2d0:	f0 92 2b 0a 	sts	0x0A2B, r15	; 0x800a2b <__RODATA_PM_OFFSET__+0x7f8a2b>
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:37
    delay(100);
 2d4:	fb de       	rcall	.-522    	; 0xcc <delay.constprop.0>
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:38
    TCA0.SINGLE.CMP1 = 582;
 2d6:	00 93 2a 0a 	sts	0x0A2A, r16	; 0x800a2a <__RODATA_PM_OFFSET__+0x7f8a2a>
 2da:	10 93 2b 0a 	sts	0x0A2B, r17	; 0x800a2b <__RODATA_PM_OFFSET__+0x7f8a2b>
/home/zach/Documents/site/people/zach/cad/fatiguetester/firmware/fatiguetester/fatiguetester.ino:39
    delay(100);
 2de:	f6 de       	rcall	.-532    	; 0xcc <delay.constprop.0>
 2e0:	ec cf       	rjmp	.-40     	; 0x2ba <main+0xdc>

000002e2 <__muluhisi3>:
__muluhisi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:626
 2e2:	09 d0       	rcall	.+18     	; 0x2f6 <__umulhisi3>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:627
 2e4:	a5 9f       	mul	r26, r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:628
 2e6:	90 0d       	add	r25, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:629
 2e8:	b4 9f       	mul	r27, r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:630
 2ea:	90 0d       	add	r25, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:631
 2ec:	a4 9f       	mul	r26, r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:632
 2ee:	80 0d       	add	r24, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:633
 2f0:	91 1d       	adc	r25, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:634
 2f2:	11 24       	eor	r1, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:635
 2f4:	08 95       	ret

000002f6 <__umulhisi3>:
__umulhisi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:564
 2f6:	a2 9f       	mul	r26, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:565
 2f8:	b0 01       	movw	r22, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:566
 2fa:	b3 9f       	mul	r27, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:567
 2fc:	c0 01       	movw	r24, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:568
 2fe:	a3 9f       	mul	r26, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:578
 300:	01 d0       	rcall	.+2      	; 0x304 <__umulhisi3+0xe>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:580
 302:	b2 9f       	mul	r27, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:581
 304:	70 0d       	add	r23, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:582
 306:	81 1d       	adc	r24, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:583
 308:	11 24       	eor	r1, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:584
 30a:	91 1d       	adc	r25, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:585
 30c:	08 95       	ret

0000030e <_exit>:
exit():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 30e:	f8 94       	cli

00000310 <__stop_program>:
__stop_program():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega3/short-calls/libgcc/../../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 310:	ff cf       	rjmp	.-2      	; 0x310 <__stop_program>
