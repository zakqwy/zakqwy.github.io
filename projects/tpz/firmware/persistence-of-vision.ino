// binary counter test
// zf 2023-04-25

#include <SPI.h>

static const uint8_t image_data_tpz[608] = {
  /*
   * combined TPZ + arrows, desaturated, tweaked, scaled to 32 px high, exported as B&W *.bmp
   * used LCD Image Converter to generate array: http://www.riuson.com/lcd-image-converter 
   */
    0x00, 0x00, 0x0f, 0xff, 
    0x00, 0x00, 0x0f, 0xff, 
    0x00, 0x00, 0x0f, 0xff, 
    0x00, 0x00, 0x0f, 0xff, 
    0x00, 0x00, 0x0f, 0xff, 
    0x00, 0x00, 0x0f, 0xff, 
    0x00, 0x00, 0x0f, 0xff, 
    0x00, 0x00, 0x0f, 0xff, 
    0x00, 0x00, 0x0f, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0x00, 0x00, 0x0f, 0xff, 
    0x00, 0x00, 0x0f, 0xff, 
    0x00, 0x00, 0x0f, 0xff, 
    0x00, 0x00, 0x0f, 0xff, 
    0x00, 0x00, 0x0f, 0xff, 
    0x00, 0x00, 0x0f, 0xff, 
    0x00, 0x00, 0x0f, 0xff, 
    0x00, 0x00, 0x0f, 0xff, 
    0x00, 0x00, 0x0f, 0xff, 
    0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 
    0x7f, 0xff, 0xff, 0xfe, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0x07, 0xe0, 0x00, 0x3f, 
    0x07, 0xe0, 0x00, 0x3f, 
    0x07, 0xe0, 0x00, 0x3f, 
    0x07, 0xff, 0xff, 0xff, 
    0x07, 0xff, 0xff, 0xfe, 
    0x07, 0xff, 0xff, 0xfe, 
    0x07, 0xff, 0xff, 0xfe, 
    0x07, 0xff, 0xff, 0xfe, 
    0x07, 0xff, 0xff, 0xfe, 
    0x03, 0xff, 0xff, 0xfe, 
    0x03, 0xff, 0xff, 0xfc, 
    0x03, 0xff, 0xff, 0xfc, 
    0x01, 0xff, 0xff, 0xfc, 
    0x01, 0xff, 0xff, 0xf8, 
    0x00, 0xff, 0xff, 0xf0, 
    0x00, 0x7f, 0xff, 0xf0, 
    0x00, 0x3f, 0xff, 0xc0, 
    0x00, 0x0f, 0xff, 0x00, 
    0x00, 0x00, 0xf8, 0x00, 
    0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 
    0xc0, 0x00, 0x0f, 0xff, 
    0xe0, 0x00, 0x0f, 0xff, 
    0xf8, 0x00, 0x0f, 0xff, 
    0xfc, 0x00, 0x0f, 0xff, 
    0xff, 0x00, 0x0f, 0xff, 
    0xff, 0xc0, 0x0f, 0xff, 
    0xff, 0xe0, 0x0f, 0xff, 
    0xff, 0xf8, 0x0f, 0xff, 
    0xff, 0xfe, 0x0f, 0xff, 
    0xff, 0xff, 0x0f, 0xff, 
    0xff, 0xff, 0xcf, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 
    0xff, 0xf7, 0xff, 0xff, 
    0xff, 0xf1, 0xff, 0xff, 
    0xff, 0xf0, 0x7f, 0xff, 
    0xff, 0xf0, 0x3f, 0xff, 
    0xff, 0xf0, 0x0f, 0xff, 
    0xff, 0xf0, 0x07, 0xff, 
    0xff, 0xf0, 0x01, 0xff, 
    0xff, 0xf0, 0x00, 0x7f, 
    0xff, 0xf0, 0x00, 0x3f, 
    0xff, 0xf0, 0x00, 0x0f, 
    0xff, 0xf0, 0x00, 0x03
};

int CLK = 18; //GPIO18
int OE = 29; //GPIO29
int SEL = 5; //GPIO5
int DATA = 19; //GPIO19
int sw_direction = 0; 
int sw_strokelimit = 1; 

int disp_delay = 0; //ms delay after sw_strokelimit --> sw_direction trigger
int line_delay = 400; //us delay per line
int img_bytes = sizeof(image_data_tpz);

void setup() {
  pinMode(CLK, OUTPUT);
  pinMode(OE, OUTPUT);
  pinMode(SEL, OUTPUT);
  pinMode(DATA, OUTPUT);

  pinMode(sw_direction, INPUT_PULLUP);
  pinMode(sw_strokelimit, INPUT_PULLUP);

  bool setTX(pin_size_t DATA);
  bool setCS(pin_size_t SEL);
  bool setSCK(pin_size_t CLK);

  SPI.begin();

  digitalWrite(OE, LOW);
}

unsigned long counter = 0;
int armed = 0;

void loop() {
  if (digitalRead(sw_strokelimit) == LOW) {
    armed = 1;
    delay(5);
  }
  if (digitalRead(sw_strokelimit == HIGH) && armed == 1) {
    if (digitalRead(sw_direction) == LOW) {
      delay(disp_delay);
      for (int i = 0; i < img_bytes; i+=4) {
        SPI.beginTransaction(SPISettings(4000000, MSBFIRST, SPI_MODE0));
        digitalWrite(SEL, LOW);
        SPI.transfer(image_data_tpz[i]);
        SPI.transfer(image_data_tpz[i+1]);
        SPI.transfer(image_data_tpz[i+2]);
        SPI.transfer(image_data_tpz[i+3]);
        digitalWrite(SEL, HIGH);
        SPI.endTransaction();
        delayMicroseconds(line_delay);

        
        /* test checkerboard
        SPI.beginTransaction(SPISettings(4000000, LSBFIRST, SPI_MODE0));
        digitalWrite(SEL, LOW);
        SPI.transfer(0x55);
        SPI.transfer(0x55);
        SPI.transfer(0x55);
        SPI.transfer(0x55);
        digitalWrite(SEL, HIGH);
        SPI.endTransaction();
        delayMicroseconds(line_delay);
        SPI.beginTransaction(SPISettings(4000000, LSBFIRST, SPI_MODE0));
        digitalWrite(SEL, LOW);
        SPI.transfer(0xAA);
        SPI.transfer(0xAA);
        SPI.transfer(0xAA);
        SPI.transfer(0xAA);
        digitalWrite(SEL, HIGH);
        SPI.endTransaction();
        delayMicroseconds(line_delay);
        */
      }
      armed = 0;
      SPI.beginTransaction(SPISettings(4000000, LSBFIRST, SPI_MODE0));
      digitalWrite(SEL, LOW);
      SPI.transfer(0);
      SPI.transfer(0);
      SPI.transfer(0);
      SPI.transfer(0);
      digitalWrite(SEL, HIGH);
      SPI.endTransaction();
      delay(500); // mechanical debouncing
    }
  }
  
  /* binary counter test
  SPI.beginTransaction(SPISettings(4000000, LSBFIRST, SPI_MODE0));
  digitalWrite(SEL, LOW);
  SPI.transfer(counter);
  SPI.transfer(counter >> 8);
  SPI.transfer(counter >> 16);
  SPI.transfer(counter >> 24);
  digitalWrite(SEL, HIGH);
  SPI.endTransaction();
  counter ++;
  */
}
